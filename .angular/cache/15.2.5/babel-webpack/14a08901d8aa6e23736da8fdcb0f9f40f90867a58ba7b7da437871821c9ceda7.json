{"ast":null,"code":"import { Chart as Chart$1 } from 'chart.js';\nimport { Injectable, NgModule, Directive, Input, Output, EventEmitter, ElementRef, defineInjectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { cloneDeep } from 'lodash';\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n/** @type {?} */\nconst defaultColors = [[255, 99, 132], [54, 162, 235], [255, 206, 86], [231, 233, 237], [75, 192, 192], [151, 187, 205], [220, 220, 220], [247, 70, 74], [70, 191, 189], [253, 180, 92], [148, 159, 177], [77, 83, 96]];\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n/**\r\n * Generate colors by chart type\r\n * @param {?} chartType\r\n * @param {?} index\r\n * @param {?} count\r\n * @return {?}\r\n */\nfunction getColors(chartType, index, count) {\n  if (chartType === 'pie' || chartType === 'doughnut') {\n    return formatPieColors(generateColors(count));\n  }\n  if (chartType === 'polarArea') {\n    return formatPolarAreaColors(generateColors(count));\n  }\n  if (chartType === 'line' || chartType === 'radar') {\n    return formatLineColor(generateColor(index));\n  }\n  if (chartType === 'bar' || chartType === 'horizontalBar') {\n    return formatBarColor(generateColor(index));\n  }\n  if (chartType === 'bubble') {\n    return formatPieColors(generateColors(count));\n  }\n  if (chartType === 'scatter') {\n    return formatPieColors(generateColors(count));\n  }\n  throw new Error(`getColors - Unsupported chart type ${chartType}`);\n}\n/**\r\n * @param {?} colour\r\n * @param {?} alpha\r\n * @return {?}\r\n */\nfunction rgba(colour, alpha) {\n  return 'rgba(' + colour.concat(alpha).join(',') + ')';\n}\n/**\r\n * @param {?} min\r\n * @param {?} max\r\n * @return {?}\r\n */\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n/**\r\n * @param {?} colors\r\n * @return {?}\r\n */\nfunction formatLineColor(colors) {\n  return {\n    backgroundColor: rgba(colors, 0.4),\n    borderColor: rgba(colors, 1),\n    pointBackgroundColor: rgba(colors, 1),\n    pointBorderColor: '#fff',\n    pointHoverBackgroundColor: '#fff',\n    pointHoverBorderColor: rgba(colors, 0.8)\n  };\n}\n/**\r\n * @param {?} colors\r\n * @return {?}\r\n */\nfunction formatBarColor(colors) {\n  return {\n    backgroundColor: rgba(colors, 0.6),\n    borderColor: rgba(colors, 1),\n    hoverBackgroundColor: rgba(colors, 0.8),\n    hoverBorderColor: rgba(colors, 1)\n  };\n}\n/**\r\n * @param {?} colors\r\n * @return {?}\r\n */\nfunction formatPieColors(colors) {\n  return {\n    backgroundColor: colors.map(\n    /**\r\n    * @param {?} color\r\n    * @return {?}\r\n    */\n    color => rgba(color, 0.6)),\n    borderColor: colors.map(\n    /**\r\n    * @return {?}\r\n    */\n    () => '#fff'),\n    pointBackgroundColor: colors.map(\n    /**\r\n    * @param {?} color\r\n    * @return {?}\r\n    */\n    color => rgba(color, 1)),\n    pointBorderColor: colors.map(\n    /**\r\n    * @return {?}\r\n    */\n    () => '#fff'),\n    pointHoverBackgroundColor: colors.map(\n    /**\r\n    * @param {?} color\r\n    * @return {?}\r\n    */\n    color => rgba(color, 1)),\n    pointHoverBorderColor: colors.map(\n    /**\r\n    * @param {?} color\r\n    * @return {?}\r\n    */\n    color => rgba(color, 1))\n  };\n}\n/**\r\n * @param {?} colors\r\n * @return {?}\r\n */\nfunction formatPolarAreaColors(colors) {\n  return {\n    backgroundColor: colors.map(\n    /**\r\n    * @param {?} color\r\n    * @return {?}\r\n    */\n    color => rgba(color, 0.6)),\n    borderColor: colors.map(\n    /**\r\n    * @param {?} color\r\n    * @return {?}\r\n    */\n    color => rgba(color, 1)),\n    hoverBackgroundColor: colors.map(\n    /**\r\n    * @param {?} color\r\n    * @return {?}\r\n    */\n    color => rgba(color, 0.8)),\n    hoverBorderColor: colors.map(\n    /**\r\n    * @param {?} color\r\n    * @return {?}\r\n    */\n    color => rgba(color, 1))\n  };\n}\n/**\r\n * @return {?}\r\n */\nfunction getRandomColor() {\n  return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];\n}\n/**\r\n * Generate colors for line|bar charts\r\n * @param {?} index\r\n * @return {?}\r\n */\nfunction generateColor(index) {\n  return defaultColors[index] || getRandomColor();\n}\n/**\r\n * Generate colors for pie|doughnut charts\r\n * @param {?} count\r\n * @return {?}\r\n */\nfunction generateColors(count) {\n  /** @type {?} */\n  const colorsArr = new Array(count);\n  for (let i = 0; i < count; i++) {\n    colorsArr[i] = defaultColors[i] || getRandomColor();\n  }\n  return colorsArr;\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass ThemeService {\n  constructor() {\n    this.pColorschemesOptions = {};\n    this.colorschemesOptions = new BehaviorSubject({});\n  }\n  /**\r\n   * @param {?} options\r\n   * @return {?}\r\n   */\n  setColorschemesOptions(options) {\n    this.pColorschemesOptions = options;\n    this.colorschemesOptions.next(options);\n  }\n  /**\r\n   * @return {?}\r\n   */\n  getColorschemesOptions() {\n    return this.pColorschemesOptions;\n  }\n}\nThemeService.decorators = [{\n  type: Injectable,\n  args: [{\n    providedIn: 'root'\n  }]\n}];\n/** @nocollapse */\nThemeService.ctorParameters = () => [];\n/** @nocollapse */\nThemeService.ngInjectableDef = defineInjectable({\n  factory: function ThemeService_Factory() {\n    return new ThemeService();\n  },\n  token: ThemeService,\n  providedIn: \"root\"\n});\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n/** @enum {number} */\nconst UpdateType = {\n  Default: 0,\n  Update: 1,\n  Refresh: 2\n};\nUpdateType[UpdateType.Default] = 'Default';\nUpdateType[UpdateType.Update] = 'Update';\nUpdateType[UpdateType.Refresh] = 'Refresh';\nclass BaseChartDirective {\n  /**\r\n   * @param {?} element\r\n   * @param {?} themeService\r\n   */\n  constructor(element, themeService) {\n    this.element = element;\n    this.themeService = themeService;\n    this.options = {};\n    this.chartClick = new EventEmitter();\n    this.chartHover = new EventEmitter();\n    this.old = {\n      dataExists: false,\n      dataLength: 0,\n      datasetsExists: false,\n      datasetsLength: 0,\n      datasetsDataObjects: [],\n      datasetsDataLengths: [],\n      colorsExists: false,\n      colors: [],\n      labelsExist: false,\n      labels: [],\n      legendExists: false,\n      legend: {}\n    };\n    this.subs = [];\n  }\n  /**\r\n   * Register a plugin.\r\n   * @param {?} plugin\r\n   * @return {?}\r\n   */\n  static registerPlugin(plugin) {\n    Chart$1.plugins.register(plugin);\n  }\n  /**\r\n   * @param {?} plugin\r\n   * @return {?}\r\n   */\n  static unregisterPlugin(plugin) {\n    Chart$1.plugins.unregister(plugin);\n  }\n  /**\r\n   * @return {?}\r\n   */\n  ngOnInit() {\n    this.ctx = this.element.nativeElement.getContext('2d');\n    this.refresh();\n    this.subs.push(this.themeService.colorschemesOptions.subscribe(\n    /**\r\n    * @param {?} r\r\n    * @return {?}\r\n    */\n    r => this.themeChanged(r)));\n  }\n  /**\r\n   * @private\r\n   * @param {?} options\r\n   * @return {?}\r\n   */\n  themeChanged(options) {\n    this.refresh();\n  }\n  /**\r\n   * @return {?}\r\n   */\n  ngDoCheck() {\n    if (!this.chart) {\n      return;\n    }\n    /** @type {?} */\n    let updateRequired = UpdateType.Default;\n    /** @type {?} */\n    const wantUpdate =\n    /**\r\n    * @param {?} x\r\n    * @return {?}\r\n    */\n    x => {\n      updateRequired = x > updateRequired ? x : updateRequired;\n    };\n    if (!!this.data !== this.old.dataExists) {\n      this.propagateDataToDatasets(this.data);\n      this.old.dataExists = !!this.data;\n      wantUpdate(UpdateType.Update);\n    }\n    if (this.data && this.data.length !== this.old.dataLength) {\n      this.old.dataLength = this.data && this.data.length || 0;\n      wantUpdate(UpdateType.Update);\n    }\n    if (!!this.datasets !== this.old.datasetsExists) {\n      this.old.datasetsExists = !!this.datasets;\n      wantUpdate(UpdateType.Update);\n    }\n    if (this.datasets && this.datasets.length !== this.old.datasetsLength) {\n      this.old.datasetsLength = this.datasets && this.datasets.length || 0;\n      wantUpdate(UpdateType.Update);\n    }\n    if (this.datasets && this.datasets.filter(\n    /**\r\n    * @param {?} x\r\n    * @param {?} i\r\n    * @return {?}\r\n    */\n    (x, i) => x.data !== this.old.datasetsDataObjects[i]).length) {\n      this.old.datasetsDataObjects = this.datasets.map(\n      /**\r\n      * @param {?} x\r\n      * @return {?}\r\n      */\n      x => x.data);\n      wantUpdate(UpdateType.Update);\n    }\n    if (this.datasets && this.datasets.filter(\n    /**\r\n    * @param {?} x\r\n    * @param {?} i\r\n    * @return {?}\r\n    */\n    (x, i) => x.data.length !== this.old.datasetsDataLengths[i]).length) {\n      this.old.datasetsDataLengths = this.datasets.map(\n      /**\r\n      * @param {?} x\r\n      * @return {?}\r\n      */\n      x => x.data.length);\n      wantUpdate(UpdateType.Update);\n    }\n    if (!!this.colors !== this.old.colorsExists) {\n      this.old.colorsExists = !!this.colors;\n      this.updateColors();\n      wantUpdate(UpdateType.Update);\n    }\n    // This smells of inefficiency, might need to revisit this\n    if (this.colors && this.colors.filter(\n    /**\r\n    * @param {?} x\r\n    * @param {?} i\r\n    * @return {?}\r\n    */\n    (x, i) => !this.colorsEqual(x, this.old.colors[i])).length) {\n      this.old.colors = this.colors.map(\n      /**\r\n      * @param {?} x\r\n      * @return {?}\r\n      */\n      x => this.copyColor(x));\n      this.updateColors();\n      wantUpdate(UpdateType.Update);\n    }\n    if (!!this.labels !== this.old.labelsExist) {\n      this.old.labelsExist = !!this.labels;\n      wantUpdate(UpdateType.Update);\n    }\n    if (this.labels && this.labels.filter(\n    /**\r\n    * @param {?} x\r\n    * @param {?} i\r\n    * @return {?}\r\n    */\n    (x, i) => !this.labelsEqual(x, this.old.labels[i])).length) {\n      this.old.labels = this.labels.map(\n      /**\r\n      * @param {?} x\r\n      * @return {?}\r\n      */\n      x => this.copyLabel(x));\n      wantUpdate(UpdateType.Update);\n    }\n    if (!!this.options.legend !== this.old.legendExists) {\n      this.old.legendExists = !!this.options.legend;\n      wantUpdate(UpdateType.Refresh);\n    }\n    if (this.options.legend && this.options.legend.position !== this.old.legend.position) {\n      this.old.legend.position = this.options.legend.position;\n      wantUpdate(UpdateType.Refresh);\n    }\n    switch ( /** @type {?} */updateRequired) {\n      case UpdateType.Default:\n        break;\n      case UpdateType.Update:\n        this.update();\n        break;\n      case UpdateType.Refresh:\n        this.refresh();\n        break;\n    }\n  }\n  /**\r\n   * @param {?} a\r\n   * @return {?}\r\n   */\n  copyLabel(a) {\n    if (Array.isArray(a)) {\n      return [...a];\n    }\n    return a;\n  }\n  /**\r\n   * @param {?} a\r\n   * @param {?} b\r\n   * @return {?}\r\n   */\n  labelsEqual(a, b) {\n    return Array.isArray(a) === Array.isArray(b) && (Array.isArray(a) || a === b) && (!Array.isArray(a) || a.length === b.length) && (!Array.isArray(a) || a.filter(\n    /**\r\n    * @param {?} x\r\n    * @param {?} i\r\n    * @return {?}\r\n    */\n    (x, i) => x !== b[i]).length === 0);\n  }\n  /**\r\n   * @param {?} a\r\n   * @return {?}\r\n   */\n  copyColor(a) {\n    /** @type {?} */\n    const rc = {\n      backgroundColor: a.backgroundColor,\n      borderWidth: a.borderWidth,\n      borderColor: a.borderColor,\n      borderCapStyle: a.borderCapStyle,\n      borderDash: a.borderDash,\n      borderDashOffset: a.borderDashOffset,\n      borderJoinStyle: a.borderJoinStyle,\n      pointBorderColor: a.pointBorderColor,\n      pointBackgroundColor: a.pointBackgroundColor,\n      pointBorderWidth: a.pointBorderWidth,\n      pointRadius: a.pointRadius,\n      pointHoverRadius: a.pointHoverRadius,\n      pointHitRadius: a.pointHitRadius,\n      pointHoverBackgroundColor: a.pointHoverBackgroundColor,\n      pointHoverBorderColor: a.pointHoverBorderColor,\n      pointHoverBorderWidth: a.pointHoverBorderWidth,\n      pointStyle: a.pointStyle,\n      hoverBackgroundColor: a.hoverBackgroundColor,\n      hoverBorderColor: a.hoverBorderColor,\n      hoverBorderWidth: a.hoverBorderWidth\n    };\n    return rc;\n  }\n  /**\r\n   * @param {?} a\r\n   * @param {?} b\r\n   * @return {?}\r\n   */\n  colorsEqual(a, b) {\n    if (!a !== !b) {\n      return false;\n    }\n    return !a || a.backgroundColor === b.backgroundColor && a.borderWidth === b.borderWidth && a.borderColor === b.borderColor && a.borderCapStyle === b.borderCapStyle && a.borderDash === b.borderDash && a.borderDashOffset === b.borderDashOffset && a.borderJoinStyle === b.borderJoinStyle && a.pointBorderColor === b.pointBorderColor && a.pointBackgroundColor === b.pointBackgroundColor && a.pointBorderWidth === b.pointBorderWidth && a.pointRadius === b.pointRadius && a.pointHoverRadius === b.pointHoverRadius && a.pointHitRadius === b.pointHitRadius && a.pointHoverBackgroundColor === b.pointHoverBackgroundColor && a.pointHoverBorderColor === b.pointHoverBorderColor && a.pointHoverBorderWidth === b.pointHoverBorderWidth && a.pointStyle === b.pointStyle && a.hoverBackgroundColor === b.hoverBackgroundColor && a.hoverBorderColor === b.hoverBorderColor && a.hoverBorderWidth === b.hoverBorderWidth;\n  }\n  /**\r\n   * @return {?}\r\n   */\n  updateColors() {\n    this.datasets.forEach(\n    /**\r\n    * @param {?} elm\r\n    * @param {?} index\r\n    * @return {?}\r\n    */\n    (elm, index) => {\n      if (this.colors && this.colors[index]) {\n        Object.assign(elm, this.colors[index]);\n      } else {\n        Object.assign(elm, getColors(this.chartType, index, elm.data.length), Object.assign({}, elm));\n      }\n    });\n  }\n  /**\r\n   * @param {?} changes\r\n   * @return {?}\r\n   */\n  ngOnChanges(changes) {\n    /** @type {?} */\n    let updateRequired = UpdateType.Default;\n    /** @type {?} */\n    const wantUpdate =\n    /**\r\n    * @param {?} x\r\n    * @return {?}\r\n    */\n    x => {\n      updateRequired = x > updateRequired ? x : updateRequired;\n    };\n    // Check if the changes are in the data or datasets or labels or legend\n    if (changes.hasOwnProperty('data') && changes.data.currentValue) {\n      this.propagateDataToDatasets(changes.data.currentValue);\n      wantUpdate(UpdateType.Update);\n    }\n    if (changes.hasOwnProperty('datasets') && changes.datasets.currentValue) {\n      this.propagateDatasetsToData(changes.datasets.currentValue);\n      wantUpdate(UpdateType.Update);\n    }\n    if (changes.hasOwnProperty('labels')) {\n      if (this.chart) {\n        this.chart.data.labels = changes.labels.currentValue;\n      }\n      wantUpdate(UpdateType.Update);\n    }\n    if (changes.hasOwnProperty('legend')) {\n      if (this.chart) {\n        this.chart.config.options.legend.display = changes.legend.currentValue;\n        this.chart.generateLegend();\n      }\n      wantUpdate(UpdateType.Update);\n    }\n    if (changes.hasOwnProperty('options')) {\n      wantUpdate(UpdateType.Refresh);\n    }\n    switch ( /** @type {?} */updateRequired) {\n      case UpdateType.Update:\n        this.update();\n        break;\n      case UpdateType.Refresh:\n      case UpdateType.Default:\n        this.refresh();\n        break;\n    }\n  }\n  /**\r\n   * @return {?}\r\n   */\n  ngOnDestroy() {\n    if (this.chart) {\n      this.chart.destroy();\n      this.chart = void 0;\n    }\n    this.subs.forEach(\n    /**\r\n    * @param {?} x\r\n    * @return {?}\r\n    */\n    x => x.unsubscribe());\n  }\n  /**\r\n   * @param {?=} duration\r\n   * @param {?=} lazy\r\n   * @return {?}\r\n   */\n  update(duration, lazy) {\n    if (this.chart) {\n      return this.chart.update(duration, lazy);\n    }\n  }\n  /**\r\n   * @param {?} index\r\n   * @param {?} hidden\r\n   * @return {?}\r\n   */\n  hideDataset(index, hidden) {\n    this.chart.getDatasetMeta(index).hidden = hidden;\n    this.chart.update();\n  }\n  /**\r\n   * @param {?} index\r\n   * @return {?}\r\n   */\n  isDatasetHidden(index) {\n    return this.chart.getDatasetMeta(index).hidden;\n  }\n  /**\r\n   * @return {?}\r\n   */\n  toBase64Image() {\n    return this.chart.toBase64Image();\n  }\n  /**\r\n   * @return {?}\r\n   */\n  getChartConfiguration() {\n    /** @type {?} */\n    const datasets = this.getDatasets();\n    /** @type {?} */\n    const options = Object.assign({}, this.options);\n    if (this.legend === false) {\n      options.legend = {\n        display: false\n      };\n    }\n    // hook for onHover and onClick events\n    options.hover = options.hover || {};\n    if (!options.hover.onHover) {\n      options.hover.onHover =\n      /**\r\n      * @param {?} event\r\n      * @param {?} active\r\n      * @return {?}\r\n      */\n      (event, active) => {\n        if (active && !active.length) {\n          return;\n        }\n        this.chartHover.emit({\n          event,\n          active\n        });\n      };\n    }\n    if (!options.onClick) {\n      options.onClick =\n      /**\r\n      * @param {?=} event\r\n      * @param {?=} active\r\n      * @return {?}\r\n      */\n      (event, active) => {\n        this.chartClick.emit({\n          event,\n          active\n        });\n      };\n    }\n    /** @type {?} */\n    const mergedOptions = this.smartMerge(options, this.themeService.getColorschemesOptions());\n    /** @type {?} */\n    const chartConfig = {\n      type: this.chartType,\n      data: {\n        labels: this.labels || [],\n        datasets\n      },\n      plugins: this.plugins,\n      options: mergedOptions\n    };\n    return chartConfig;\n  }\n  /**\r\n   * @param {?} ctx\r\n   * @return {?}\r\n   */\n  getChartBuilder(ctx /*, data:any[], options:any*/) {\n    /** @type {?} */\n    const chartConfig = this.getChartConfiguration();\n    return new Chart$1(ctx, chartConfig);\n  }\n  /**\r\n   * @param {?} options\r\n   * @param {?} overrides\r\n   * @param {?=} level\r\n   * @return {?}\r\n   */\n  smartMerge(options, overrides, level = 0) {\n    if (level === 0) {\n      options = cloneDeep(options);\n    }\n    /** @type {?} */\n    const keysToUpdate = Object.keys(overrides);\n    keysToUpdate.forEach(\n    /**\r\n    * @param {?} key\r\n    * @return {?}\r\n    */\n    key => {\n      if (Array.isArray(overrides[key])) {\n        /** @type {?} */\n        const arrayElements = options[key];\n        if (arrayElements) {\n          arrayElements.forEach(\n          /**\r\n          * @param {?} r\r\n          * @return {?}\r\n          */\n          r => {\n            this.smartMerge(r, overrides[key][0], level + 1);\n          });\n        }\n      } else if (typeof overrides[key] === 'object') {\n        if (!(key in options)) {\n          options[key] = {};\n        }\n        this.smartMerge(options[key], overrides[key], level + 1);\n      } else {\n        options[key] = overrides[key];\n      }\n    });\n    if (level === 0) {\n      return options;\n    }\n  }\n  /**\r\n   * @private\r\n   * @param {?} label\r\n   * @return {?}\r\n   */\n  isMultiLineLabel(label) {\n    return Array.isArray(label);\n  }\n  /**\r\n   * @private\r\n   * @param {?} label\r\n   * @return {?}\r\n   */\n  joinLabel(label) {\n    if (!label) {\n      return null;\n    }\n    if (this.isMultiLineLabel(label)) {\n      return label.join(' ');\n    } else {\n      return label;\n    }\n  }\n  /**\r\n   * @private\r\n   * @param {?} datasets\r\n   * @return {?}\r\n   */\n  propagateDatasetsToData(datasets) {\n    this.data = this.datasets.map(\n    /**\r\n    * @param {?} r\r\n    * @return {?}\r\n    */\n    r => r.data);\n    if (this.chart) {\n      this.chart.data.datasets = datasets;\n    }\n    this.updateColors();\n  }\n  /**\r\n   * @private\r\n   * @param {?} newDataValues\r\n   * @return {?}\r\n   */\n  propagateDataToDatasets(newDataValues) {\n    if (this.isMultiDataSet(newDataValues)) {\n      if (this.datasets && newDataValues.length === this.datasets.length) {\n        this.datasets.forEach(\n        /**\r\n        * @param {?} dataset\r\n        * @param {?} i\r\n        * @return {?}\r\n        */\n        (dataset, i) => {\n          dataset.data = newDataValues[i];\n        });\n      } else {\n        this.datasets = newDataValues.map(\n        /**\r\n        * @param {?} data\r\n        * @param {?} index\r\n        * @return {?}\r\n        */\n        (data, index) => {\n          return {\n            data,\n            label: this.joinLabel(this.labels[index]) || `Label ${index}`\n          };\n        });\n        if (this.chart) {\n          this.chart.data.datasets = this.datasets;\n        }\n      }\n    } else {\n      if (!this.datasets) {\n        this.datasets = [{\n          data: newDataValues\n        }];\n        if (this.chart) {\n          this.chart.data.datasets = this.datasets;\n        }\n      } else {\n        this.datasets[0].data = newDataValues;\n        this.datasets.splice(1); // Remove all elements but the first\n      }\n    }\n\n    this.updateColors();\n  }\n  /**\r\n   * @private\r\n   * @param {?} data\r\n   * @return {?}\r\n   */\n  isMultiDataSet(data) {\n    return Array.isArray(data[0]);\n  }\n  /**\r\n   * @private\r\n   * @return {?}\r\n   */\n  getDatasets() {\n    if (!this.datasets && !this.data) {\n      throw new Error(`ng-charts configuration error, data or datasets field are required to render chart ${this.chartType}`);\n    }\n    // If `datasets` is defined, use it over the `data` property.\n    if (this.datasets) {\n      this.propagateDatasetsToData(this.datasets);\n      return this.datasets;\n    }\n    if (this.data) {\n      this.propagateDataToDatasets(this.data);\n      return this.datasets;\n    }\n  }\n  /**\r\n   * @private\r\n   * @return {?}\r\n   */\n  refresh() {\n    // if (this.options && this.options.responsive) {\n    //   setTimeout(() => this.refresh(), 50);\n    // }\n    // todo: remove this line, it is producing flickering\n    if (this.chart) {\n      this.chart.destroy();\n      this.chart = void 0;\n    }\n    if (this.ctx) {\n      this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);\n    }\n  }\n}\n\nBaseChartDirective.decorators = [{\n  type: Directive,\n  args: [{\n    // tslint:disable-next-line:directive-selector\n    selector: 'canvas[baseChart]',\n    exportAs: 'base-chart'\n  }]\n}];\n/** @nocollapse */\nBaseChartDirective.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: ThemeService\n}];\nBaseChartDirective.propDecorators = {\n  data: [{\n    type: Input\n  }],\n  datasets: [{\n    type: Input\n  }],\n  labels: [{\n    type: Input\n  }],\n  options: [{\n    type: Input\n  }],\n  chartType: [{\n    type: Input\n  }],\n  colors: [{\n    type: Input\n  }],\n  legend: [{\n    type: Input\n  }],\n  plugins: [{\n    type: Input\n  }],\n  chartClick: [{\n    type: Output\n  }],\n  chartHover: [{\n    type: Output\n  }]\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass ChartsModule {}\nChartsModule.decorators = [{\n  type: NgModule,\n  args: [{\n    declarations: [BaseChartDirective],\n    imports: [],\n    exports: [BaseChartDirective]\n  }]\n}];\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n// tslint:disable:variable-name\n// tslint:disable:no-var-keyword\n// tslint:disable:prefer-const\n// tslint:disable:only-arrow-functions\n// tslint:disable:one-variable-per-declaration\n// tslint:disable:object-literal-shorthand\n// tslint:disable:space-before-function-paren\n/**\r\n * @return {?}\r\n */\nfunction monkeyPatchChartJsLegend() {\n  if (typeof Chart === 'undefined') {\n    console.log('Chart not defined (guessing this is a universal build, and I don\\'t know why this happens -- Aviad)');\n    return;\n  }\n  /** @type {?} */\n  const plugins = Chart.plugins.getAll();\n  /** @type {?} */\n  const legend = plugins.filter(\n  /**\r\n  * @param {?} p\r\n  * @return {?}\r\n  */\n  p => p.id === 'legend')[0];\n  legend._element.prototype.fit = fit;\n  legend._element.prototype.draw = draw;\n  /** @type {?} */\n  const helpers = Chart.helpers;\n  /** @type {?} */\n  const defaults = Chart.defaults;\n  /** @type {?} */\n  const valueOrDefault = helpers.valueOrDefault;\n  /**\r\n   * @param {?} labelOpts\r\n   * @param {?} fontSize\r\n   * @return {?}\r\n   */\n  function getBoxWidth(labelOpts, fontSize) {\n    return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;\n  }\n  /**\r\n   * @return {?}\r\n   */\n  function fit() {\n    /** @type {?} */\n    var me = this;\n    /** @type {?} */\n    var opts = me.options;\n    /** @type {?} */\n    var labelOpts = opts.labels;\n    /** @type {?} */\n    var display = opts.display;\n    /** @type {?} */\n    var ctx = me.ctx;\n    /** @type {?} */\n    var labelFont = helpers.options._parseFont(labelOpts);\n    /** @type {?} */\n    var fontSize = labelFont.size;\n    // Reset hit boxes\n    /** @type {?} */\n    var hitboxes = me.legendHitBoxes = [];\n    /** @type {?} */\n    var minSize = me.minSize;\n    /** @type {?} */\n    var isHorizontal = me.isHorizontal();\n    if (isHorizontal) {\n      minSize.width = me.maxWidth; // fill all the width\n      minSize.height = display ? 10 : 0;\n    } else {\n      minSize.width = display ? 10 : 0;\n      minSize.height = me.maxHeight; // fill all the height\n    }\n    /** @type {?} */\n    var getMaxLineWidth =\n    /**\r\n    * @param {?} textLines\r\n    * @return {?}\r\n    */\n    function (textLines) {\n      return textLines.map(\n      /**\r\n      * @param {?} textLine\r\n      * @return {?}\r\n      */\n      function (textLine) {\n        return ctx.measureText(textLine).width;\n      }).reduce(\n      /**\r\n      * @param {?} acc\r\n      * @param {?} v\r\n      * @return {?}\r\n      */\n      function (acc, v) {\n        return v > acc ? v : acc;\n      }, 0);\n    };\n    // Increase sizes here\n    if (display) {\n      ctx.font = labelFont.string;\n      if (isHorizontal) {\n        // Labels\n        // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n        /** @type {?} */\n        var lineWidths = me.lineWidths = [0];\n        /** @type {?} */\n        var lineHeights = me.lineHeights = [];\n        /** @type {?} */\n        var currentLineHeight = 0;\n        /** @type {?} */\n        var lineIndex = 0;\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'top';\n        helpers.each(me.legendItems,\n        /**\r\n        * @param {?} legendItem\r\n        * @param {?} i\r\n        * @return {?}\r\n        */\n        function (legendItem, i) {\n          /** @type {?} */\n          var width;\n          /** @type {?} */\n          var height;\n          if (helpers.isArray(legendItem.text)) {\n            width = getMaxLineWidth(legendItem.text);\n            height = fontSize * legendItem.text.length + labelOpts.padding;\n          } else {\n            width = ctx.measureText(legendItem.text).width;\n            height = fontSize + labelOpts.padding;\n          }\n          width += getBoxWidth(labelOpts, fontSize) + fontSize / 2;\n          if (lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {\n            lineHeights.push(currentLineHeight);\n            currentLineHeight = 0;\n            lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n            lineIndex++;\n          }\n          legendItem.lineOrColumnIndex = lineIndex;\n          if (height > currentLineHeight) {\n            currentLineHeight = height;\n          }\n          // Store the hitbox width and height here. Final position will be updated in `draw`\n          hitboxes[i] = {\n            left: 0,\n            top: 0,\n            width: width,\n            height: height\n          };\n          lineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n        });\n        lineHeights.push(currentLineHeight);\n        minSize.height += lineHeights.reduce(\n        /**\r\n        * @param {?} acc\r\n        * @param {?} v\r\n        * @return {?}\r\n        */\n        function (acc, v) {\n          return acc + v;\n        }, 0);\n      } else {\n        /** @type {?} */\n        var vPadding = labelOpts.padding;\n        /** @type {?} */\n        var columnWidths = me.columnWidths = [];\n        /** @type {?} */\n        var columnHeights = me.columnHeights = [];\n        /** @type {?} */\n        var totalWidth = labelOpts.padding;\n        /** @type {?} */\n        var currentColWidth = 0;\n        /** @type {?} */\n        var currentColHeight = 0;\n        /** @type {?} */\n        var columnIndex = 0;\n        helpers.each(me.legendItems,\n        /**\r\n        * @param {?} legendItem\r\n        * @param {?} i\r\n        * @return {?}\r\n        */\n        function (legendItem, i) {\n          /** @type {?} */\n          var itemWidth;\n          /** @type {?} */\n          var height;\n          if (helpers.isArray(legendItem.text)) {\n            itemWidth = getMaxLineWidth(legendItem.text);\n            height = fontSize * legendItem.text.length;\n          } else {\n            itemWidth = ctx.measureText(legendItem.text).width;\n            height = fontSize;\n          }\n          itemWidth += getBoxWidth(labelOpts, fontSize) + fontSize / 2;\n          // If too tall, go to new column\n          if (currentColHeight + fontSize + 2 * vPadding > minSize.height) {\n            totalWidth += currentColWidth + labelOpts.padding;\n            columnWidths.push(currentColWidth); // previous column width\n            columnHeights.push(currentColHeight);\n            currentColWidth = 0;\n            currentColHeight = 0;\n            columnIndex++;\n          }\n          legendItem.lineOrColumnIndex = columnIndex;\n          // Get max width\n          currentColWidth = Math.max(currentColWidth, itemWidth);\n          currentColHeight += height + vPadding;\n          // Store the hitbox width and height here. Final position will be updated in `draw`\n          hitboxes[i] = {\n            left: 0,\n            top: 0,\n            width: itemWidth,\n            height: height\n          };\n        });\n        totalWidth += currentColWidth;\n        columnWidths.push(currentColWidth);\n        columnHeights.push(currentColHeight);\n        minSize.width += totalWidth;\n      }\n    }\n    me.width = minSize.width;\n    me.height = minSize.height;\n  }\n  /**\r\n   * @return {?}\r\n   */\n  function draw() {\n    /** @type {?} */\n    var me = this;\n    /** @type {?} */\n    var opts = me.options;\n    /** @type {?} */\n    var labelOpts = opts.labels;\n    /** @type {?} */\n    var globalDefaults = defaults.global;\n    /** @type {?} */\n    var defaultColor = globalDefaults.defaultColor;\n    /** @type {?} */\n    var lineDefault = globalDefaults.elements.line;\n    /** @type {?} */\n    var legendHeight = me.height;\n    /** @type {?} */\n    var columnHeights = me.columnHeights;\n    /** @type {?} */\n    var columnWidths = me.columnWidths;\n    /** @type {?} */\n    var legendWidth = me.width;\n    /** @type {?} */\n    var lineWidths = me.lineWidths;\n    /** @type {?} */\n    var lineHeights = me.lineHeights;\n    if (opts.display) {\n      /** @type {?} */\n      var ctx = me.ctx;\n      /** @type {?} */\n      var fontColor = valueOrDefault(labelOpts.fontColor, globalDefaults.defaultFontColor);\n      /** @type {?} */\n      var labelFont = helpers.options._parseFont(labelOpts);\n      /** @type {?} */\n      var fontSize = labelFont.size;\n      /** @type {?} */\n      var cursor;\n      // Canvas setup\n      ctx.textAlign = 'left';\n      ctx.textBaseline = 'middle';\n      ctx.lineWidth = 0.5;\n      ctx.strokeStyle = fontColor; // for strikethrough effect\n      ctx.fillStyle = fontColor; // render in correct colour\n      ctx.font = labelFont.string;\n      /** @type {?} */\n      var boxWidth = getBoxWidth(labelOpts, fontSize);\n      /** @type {?} */\n      var hitboxes = me.legendHitBoxes;\n      // current position\n      /** @type {?} */\n      var drawLegendBox =\n      /**\r\n      * @param {?} x\r\n      * @param {?} y\r\n      * @param {?} legendItem\r\n      * @return {?}\r\n      */\n      function (x, y, legendItem) {\n        if (isNaN(boxWidth) || boxWidth <= 0) {\n          return;\n        }\n        // Set the ctx for the box\n        ctx.save();\n        /** @type {?} */\n        var lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n        ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n        if (ctx.setLineDash) {\n          // IE 9 and 10 do not support line dash\n          ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));\n        }\n        if (opts.labels && opts.labels.usePointStyle) {\n          // Recalculate x and y for drawPoint() because its expecting\n          // x and y to be center of figure (instead of top left)\n          /** @type {?} */\n          var radius = boxWidth * Math.SQRT2 / 2;\n          /** @type {?} */\n          var centerX = x + boxWidth / 2;\n          /** @type {?} */\n          var centerY = y + fontSize / 2;\n          // Draw pointStyle as legend symbol\n          helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n        } else {\n          // Draw box as legend symbol\n          if (lineWidth !== 0) {\n            ctx.strokeRect(x, y, boxWidth, fontSize);\n          }\n          ctx.fillRect(x, y, boxWidth, fontSize);\n        }\n        ctx.restore();\n      };\n      /** @type {?} */\n      var drawStrikeThrough =\n      /**\r\n      * @param {?} x\r\n      * @param {?} y\r\n      * @param {?} w\r\n      * @return {?}\r\n      */\n      function (x, y, w) {\n        ctx.beginPath();\n        ctx.lineWidth = 2;\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + w, y);\n        ctx.stroke();\n      };\n      /** @type {?} */\n      var drawCrossOver =\n      /**\r\n      * @param {?} x\r\n      * @param {?} y\r\n      * @param {?} w\r\n      * @param {?} h\r\n      * @return {?}\r\n      */\n      function (x, y, w, h) {\n        ctx.beginPath();\n        ctx.lineWidth = 2;\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + w, y + h);\n        ctx.moveTo(x, y + h);\n        ctx.lineTo(x + w, y);\n        ctx.stroke();\n      };\n      /** @type {?} */\n      var fillText =\n      /**\r\n      * @param {?} x\r\n      * @param {?} y\r\n      * @param {?} legendItem\r\n      * @param {?} textWidth\r\n      * @return {?}\r\n      */\n      function (x, y, legendItem, textWidth) {\n        /** @type {?} */\n        var halfFontSize = fontSize / 2;\n        /** @type {?} */\n        var xLeft = boxWidth + halfFontSize + x;\n        /** @type {?} */\n        var yMiddle = y + halfFontSize;\n        if (helpers.isArray(legendItem.text)) {\n          helpers.each(legendItem.text,\n          /**\r\n          * @param {?} textLine\r\n          * @param {?} index\r\n          * @return {?}\r\n          */\n          function (textLine, index) {\n            /** @type {?} */\n            var lineOffset = index * fontSize;\n            ctx.fillText(textLine, xLeft, yMiddle + lineOffset);\n          });\n        } else {\n          ctx.fillText(legendItem.text, xLeft, yMiddle);\n        }\n        if (legendItem.hidden) {\n          if (helpers.isArray(legendItem.text)) {\n            drawCrossOver(xLeft, yMiddle, textWidth, (legendItem.text.length - 1) * (fontSize - 1));\n          } else {\n            drawStrikeThrough(xLeft, yMiddle, textWidth);\n          }\n        }\n      };\n      /** @type {?} */\n      var alignmentOffset =\n      /**\r\n      * @param {?} dimension\r\n      * @param {?} blockSize\r\n      * @return {?}\r\n      */\n      function (dimension, blockSize) {\n        switch (opts.align) {\n          case 'start':\n            return labelOpts.padding;\n          case 'end':\n            return dimension - blockSize;\n          default:\n            // center\n            return (dimension - blockSize + labelOpts.padding) / 2;\n        }\n      };\n      // Horizontal\n      /** @type {?} */\n      var isHorizontal = me.isHorizontal();\n      if (isHorizontal) {\n        cursor = {\n          x: me.left + alignmentOffset(legendWidth, lineWidths[0]),\n          y: me.top + labelOpts.padding,\n          line: 0\n        };\n      } else {\n        cursor = {\n          x: me.left + labelOpts.padding,\n          y: me.top + alignmentOffset(legendHeight, columnHeights[0]),\n          line: 0\n        };\n      }\n      helpers.each(me.legendItems,\n      /**\r\n      * @param {?} legendItem\r\n      * @param {?} i\r\n      * @return {?}\r\n      */\n      function (legendItem, i) {\n        /** @type {?} */\n        var textWidth;\n        /** @type {?} */\n        var height;\n        /** @type {?} */\n        var boxTopOffset;\n        if (legendItem.lineOrColumnIndex > cursor.line) {\n          if (isHorizontal) {\n            cursor.y += lineHeights[cursor.line];\n            cursor.line = legendItem.lineOrColumnIndex;\n            cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);\n          } else {\n            cursor.x += columnWidths[cursor.line] + labelOpts.padding;\n            cursor.line = legendItem.lineOrColumnIndex;\n            cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);\n          }\n        }\n        if (helpers.isArray(legendItem.text)) {\n          textWidth = legendItem.text.map(\n          /**\r\n          * @param {?} textLine\r\n          * @return {?}\r\n          */\n          function (textLine) {\n            return ctx.measureText(textLine).width;\n          }).reduce(\n          /**\r\n          * @param {?} acc\r\n          * @param {?} v\r\n          * @return {?}\r\n          */\n          function (acc, v) {\n            return v > acc ? v : acc;\n          }, 0);\n          boxTopOffset = fontSize / 2 * (legendItem.text.length - 1);\n          height = fontSize * legendItem.text.length;\n        } else {\n          textWidth = ctx.measureText(legendItem.text).width;\n          boxTopOffset = 0;\n          height = fontSize;\n        }\n        /** @type {?} */\n        var width = boxWidth + fontSize / 2 + textWidth;\n        /** @type {?} */\n        var x = cursor.x;\n        /** @type {?} */\n        var y = cursor.y;\n        /** @type {?} */\n        var topOffset = isHorizontal ? Math.trunc((lineHeights[cursor.line] - hitboxes[i].height) / 2) : 0;\n        drawLegendBox(x, y + boxTopOffset + topOffset, legendItem);\n        hitboxes[i].left = x;\n        hitboxes[i].top = y;\n        // Fill the actual label\n        fillText(x, y + topOffset, legendItem, textWidth);\n        if (isHorizontal) {\n          cursor.x += width + labelOpts.padding;\n        } else {\n          cursor.y += height + labelOpts.padding;\n        }\n      });\n    }\n  }\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n// tslint:disable:variable-name\n// tslint:disable:no-var-keyword\n// tslint:disable:prefer-const\n// tslint:disable:only-arrow-functions\n// tslint:disable:one-variable-per-declaration\n// tslint:disable:object-literal-shorthand\n// tslint:disable:space-before-function-paren\n/**\r\n * @return {?}\r\n */\nfunction monkeyPatchChartJsTooltip() {\n  if (typeof Chart === 'undefined') {\n    console.log('Chart not defined (guessing this is a universal build, and I don\\'t know why this happens -- Aviad)');\n    return;\n  }\n  Chart.Tooltip.prototype.drawBody = drawBody;\n  /** @type {?} */\n  const helpers = Chart.helpers;\n  /**\r\n   * @param {?} vm\r\n   * @param {?} align\r\n   * @return {?}\r\n   */\n  function getAlignedX(vm, align) {\n    return align === 'center' ? vm.x + vm.width / 2 : align === 'right' ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;\n  }\n  /**\r\n   * @param {?} pt\r\n   * @param {?} vm\r\n   * @param {?} ctx\r\n   * @return {?}\r\n   */\n  function drawBody(pt, vm, ctx) {\n    /** @type {?} */\n    var bodyFontSize = vm.bodyFontSize;\n    /** @type {?} */\n    var bodySpacing = vm.bodySpacing;\n    /** @type {?} */\n    var bodyAlign = vm._bodyAlign;\n    /** @type {?} */\n    var body = vm.body;\n    /** @type {?} */\n    var drawColorBoxes = vm.displayColors;\n    /** @type {?} */\n    var labelColors = vm.labelColors;\n    /** @type {?} */\n    var xLinePadding = 0;\n    /** @type {?} */\n    var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;\n    /** @type {?} */\n    var textColor;\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'top';\n    ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n    pt.x = getAlignedX(vm, bodyAlign);\n    // Before Body\n    /** @type {?} */\n    var fillLineOfText =\n    /**\r\n    * @param {?} line\r\n    * @return {?}\r\n    */\n    function (line) {\n      ctx.fillText(line, pt.x + xLinePadding, pt.y);\n      pt.y += bodyFontSize + bodySpacing;\n    };\n    // Before body lines\n    ctx.fillStyle = vm.bodyFontColor;\n    helpers.each(vm.beforeBody, fillLineOfText);\n    xLinePadding = drawColorBoxes && bodyAlign !== 'right' ? bodyAlign === 'center' ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0;\n    // Draw body lines now\n    helpers.each(body,\n    /**\r\n    * @param {?} bodyItem\r\n    * @param {?} i\r\n    * @return {?}\r\n    */\n    function (bodyItem, i) {\n      textColor = vm.labelTextColors[i];\n      ctx.fillStyle = textColor;\n      helpers.each(bodyItem.before, fillLineOfText);\n      // Draw Legend-like boxes if needed\n      if (drawColorBoxes) {\n        // Fill a white rect so that colours merge nicely if the opacity is < 1\n        ctx.fillStyle = vm.legendColorBackground;\n        ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize);\n        // Border\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = labelColors[i].borderColor;\n        ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize);\n        // Inner square\n        ctx.fillStyle = labelColors[i].backgroundColor;\n        ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n        ctx.fillStyle = textColor;\n      }\n      helpers.each(bodyItem.lines, fillLineOfText);\n      helpers.each(bodyItem.after, fillLineOfText);\n    });\n    // Reset back to 0 for after body\n    xLinePadding = 0;\n    // After body lines\n    helpers.each(vm.afterBody, fillLineOfText);\n    pt.y -= bodySpacing; // Remove last body spacing\n  }\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\nexport { ChartsModule, BaseChartDirective, defaultColors, ThemeService, monkeyPatchChartJsLegend, monkeyPatchChartJsTooltip };","map":{"version":3,"names":["Chart","Chart$1","Injectable","NgModule","Directive","Input","Output","EventEmitter","ElementRef","defineInjectable","BehaviorSubject","cloneDeep","defaultColors","getColors","chartType","index","count","formatPieColors","generateColors","formatPolarAreaColors","formatLineColor","generateColor","formatBarColor","Error","rgba","colour","alpha","concat","join","getRandomInt","min","max","Math","floor","random","colors","backgroundColor","borderColor","pointBackgroundColor","pointBorderColor","pointHoverBackgroundColor","pointHoverBorderColor","hoverBackgroundColor","hoverBorderColor","map","color","getRandomColor","colorsArr","Array","i","ThemeService","constructor","pColorschemesOptions","colorschemesOptions","setColorschemesOptions","options","next","getColorschemesOptions","decorators","type","args","providedIn","ctorParameters","ngInjectableDef","factory","ThemeService_Factory","token","UpdateType","Default","Update","Refresh","BaseChartDirective","element","themeService","chartClick","chartHover","old","dataExists","dataLength","datasetsExists","datasetsLength","datasetsDataObjects","datasetsDataLengths","colorsExists","labelsExist","labels","legendExists","legend","subs","registerPlugin","plugin","plugins","register","unregisterPlugin","unregister","ngOnInit","ctx","nativeElement","getContext","refresh","push","subscribe","r","themeChanged","ngDoCheck","chart","updateRequired","wantUpdate","x","data","propagateDataToDatasets","length","datasets","filter","updateColors","colorsEqual","copyColor","labelsEqual","copyLabel","position","update","a","isArray","b","rc","borderWidth","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","pointBorderWidth","pointRadius","pointHoverRadius","pointHitRadius","pointHoverBorderWidth","pointStyle","hoverBorderWidth","forEach","elm","Object","assign","ngOnChanges","changes","hasOwnProperty","currentValue","propagateDatasetsToData","config","display","generateLegend","ngOnDestroy","destroy","unsubscribe","duration","lazy","hideDataset","hidden","getDatasetMeta","isDatasetHidden","toBase64Image","getChartConfiguration","getDatasets","hover","onHover","event","active","emit","onClick","mergedOptions","smartMerge","chartConfig","getChartBuilder","overrides","level","keysToUpdate","keys","key","arrayElements","isMultiLineLabel","label","joinLabel","newDataValues","isMultiDataSet","dataset","splice","selector","exportAs","propDecorators","ChartsModule","declarations","imports","exports","monkeyPatchChartJsLegend","console","log","getAll","p","id","_element","prototype","fit","draw","helpers","defaults","valueOrDefault","getBoxWidth","labelOpts","fontSize","usePointStyle","boxWidth","me","opts","labelFont","_parseFont","size","hitboxes","legendHitBoxes","minSize","isHorizontal","width","maxWidth","height","maxHeight","getMaxLineWidth","textLines","textLine","measureText","reduce","acc","v","font","string","lineWidths","lineHeights","currentLineHeight","lineIndex","textAlign","textBaseline","each","legendItems","legendItem","text","padding","lineOrColumnIndex","left","top","vPadding","columnWidths","columnHeights","totalWidth","currentColWidth","currentColHeight","columnIndex","itemWidth","globalDefaults","global","defaultColor","lineDefault","elements","line","legendHeight","legendWidth","fontColor","defaultFontColor","cursor","lineWidth","strokeStyle","fillStyle","drawLegendBox","y","isNaN","save","lineCap","lineDashOffset","lineJoin","setLineDash","lineDash","radius","SQRT2","centerX","centerY","canvas","drawPoint","strokeRect","fillRect","restore","drawStrikeThrough","w","beginPath","moveTo","lineTo","stroke","drawCrossOver","h","fillText","textWidth","halfFontSize","xLeft","yMiddle","lineOffset","alignmentOffset","dimension","blockSize","align","boxTopOffset","topOffset","trunc","monkeyPatchChartJsTooltip","Tooltip","drawBody","getAlignedX","vm","xPadding","pt","bodyFontSize","bodySpacing","bodyAlign","_bodyAlign","body","drawColorBoxes","displayColors","labelColors","xLinePadding","colorX","textColor","fontString","_bodyFontStyle","_bodyFontFamily","fillLineOfText","bodyFontColor","beforeBody","bodyItem","labelTextColors","before","legendColorBackground","lines","after","afterBody"],"sources":["C:/Users/aicha/Desktop/pfe/node_modules/ng2-charts/fesm2015/ng2-charts.js"],"sourcesContent":["import { Chart as Chart$1 } from 'chart.js';\nimport { Injectable, NgModule, Directive, Input, Output, EventEmitter, ElementRef, defineInjectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { cloneDeep } from 'lodash';\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @type {?} */\r\nconst defaultColors = [\r\n    [255, 99, 132],\r\n    [54, 162, 235],\r\n    [255, 206, 86],\r\n    [231, 233, 237],\r\n    [75, 192, 192],\r\n    [151, 187, 205],\r\n    [220, 220, 220],\r\n    [247, 70, 74],\r\n    [70, 191, 189],\r\n    [253, 180, 92],\r\n    [148, 159, 177],\r\n    [77, 83, 96]\r\n];\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Generate colors by chart type\r\n * @param {?} chartType\r\n * @param {?} index\r\n * @param {?} count\r\n * @return {?}\r\n */\r\nfunction getColors(chartType, index, count) {\r\n    if (chartType === 'pie' || chartType === 'doughnut') {\r\n        return formatPieColors(generateColors(count));\r\n    }\r\n    if (chartType === 'polarArea') {\r\n        return formatPolarAreaColors(generateColors(count));\r\n    }\r\n    if (chartType === 'line' || chartType === 'radar') {\r\n        return formatLineColor(generateColor(index));\r\n    }\r\n    if (chartType === 'bar' || chartType === 'horizontalBar') {\r\n        return formatBarColor(generateColor(index));\r\n    }\r\n    if (chartType === 'bubble') {\r\n        return formatPieColors(generateColors(count));\r\n    }\r\n    if (chartType === 'scatter') {\r\n        return formatPieColors(generateColors(count));\r\n    }\r\n    throw new Error(`getColors - Unsupported chart type ${chartType}`);\r\n}\r\n/**\r\n * @param {?} colour\r\n * @param {?} alpha\r\n * @return {?}\r\n */\r\nfunction rgba(colour, alpha) {\r\n    return 'rgba(' + colour.concat(alpha).join(',') + ')';\r\n}\r\n/**\r\n * @param {?} min\r\n * @param {?} max\r\n * @return {?}\r\n */\r\nfunction getRandomInt(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n/**\r\n * @param {?} colors\r\n * @return {?}\r\n */\r\nfunction formatLineColor(colors) {\r\n    return {\r\n        backgroundColor: rgba(colors, 0.4),\r\n        borderColor: rgba(colors, 1),\r\n        pointBackgroundColor: rgba(colors, 1),\r\n        pointBorderColor: '#fff',\r\n        pointHoverBackgroundColor: '#fff',\r\n        pointHoverBorderColor: rgba(colors, 0.8)\r\n    };\r\n}\r\n/**\r\n * @param {?} colors\r\n * @return {?}\r\n */\r\nfunction formatBarColor(colors) {\r\n    return {\r\n        backgroundColor: rgba(colors, 0.6),\r\n        borderColor: rgba(colors, 1),\r\n        hoverBackgroundColor: rgba(colors, 0.8),\r\n        hoverBorderColor: rgba(colors, 1)\r\n    };\r\n}\r\n/**\r\n * @param {?} colors\r\n * @return {?}\r\n */\r\nfunction formatPieColors(colors) {\r\n    return {\r\n        backgroundColor: colors.map((/**\r\n         * @param {?} color\r\n         * @return {?}\r\n         */\r\n        (color) => rgba(color, 0.6))),\r\n        borderColor: colors.map((/**\r\n         * @return {?}\r\n         */\r\n        () => '#fff')),\r\n        pointBackgroundColor: colors.map((/**\r\n         * @param {?} color\r\n         * @return {?}\r\n         */\r\n        (color) => rgba(color, 1))),\r\n        pointBorderColor: colors.map((/**\r\n         * @return {?}\r\n         */\r\n        () => '#fff')),\r\n        pointHoverBackgroundColor: colors.map((/**\r\n         * @param {?} color\r\n         * @return {?}\r\n         */\r\n        (color) => rgba(color, 1))),\r\n        pointHoverBorderColor: colors.map((/**\r\n         * @param {?} color\r\n         * @return {?}\r\n         */\r\n        (color) => rgba(color, 1)))\r\n    };\r\n}\r\n/**\r\n * @param {?} colors\r\n * @return {?}\r\n */\r\nfunction formatPolarAreaColors(colors) {\r\n    return {\r\n        backgroundColor: colors.map((/**\r\n         * @param {?} color\r\n         * @return {?}\r\n         */\r\n        (color) => rgba(color, 0.6))),\r\n        borderColor: colors.map((/**\r\n         * @param {?} color\r\n         * @return {?}\r\n         */\r\n        (color) => rgba(color, 1))),\r\n        hoverBackgroundColor: colors.map((/**\r\n         * @param {?} color\r\n         * @return {?}\r\n         */\r\n        (color) => rgba(color, 0.8))),\r\n        hoverBorderColor: colors.map((/**\r\n         * @param {?} color\r\n         * @return {?}\r\n         */\r\n        (color) => rgba(color, 1)))\r\n    };\r\n}\r\n/**\r\n * @return {?}\r\n */\r\nfunction getRandomColor() {\r\n    return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];\r\n}\r\n/**\r\n * Generate colors for line|bar charts\r\n * @param {?} index\r\n * @return {?}\r\n */\r\nfunction generateColor(index) {\r\n    return defaultColors[index] || getRandomColor();\r\n}\r\n/**\r\n * Generate colors for pie|doughnut charts\r\n * @param {?} count\r\n * @return {?}\r\n */\r\nfunction generateColors(count) {\r\n    /** @type {?} */\r\n    const colorsArr = new Array(count);\r\n    for (let i = 0; i < count; i++) {\r\n        colorsArr[i] = defaultColors[i] || getRandomColor();\r\n    }\r\n    return colorsArr;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass ThemeService {\r\n    constructor() {\r\n        this.pColorschemesOptions = {};\r\n        this.colorschemesOptions = new BehaviorSubject({});\r\n    }\r\n    /**\r\n     * @param {?} options\r\n     * @return {?}\r\n     */\r\n    setColorschemesOptions(options) {\r\n        this.pColorschemesOptions = options;\r\n        this.colorschemesOptions.next(options);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    getColorschemesOptions() {\r\n        return this.pColorschemesOptions;\r\n    }\r\n}\r\nThemeService.decorators = [\r\n    { type: Injectable, args: [{\r\n                providedIn: 'root'\r\n            },] }\r\n];\r\n/** @nocollapse */\r\nThemeService.ctorParameters = () => [];\r\n/** @nocollapse */ ThemeService.ngInjectableDef = defineInjectable({ factory: function ThemeService_Factory() { return new ThemeService(); }, token: ThemeService, providedIn: \"root\" });\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/** @enum {number} */\r\nconst UpdateType = {\r\n    Default: 0,\r\n    Update: 1,\r\n    Refresh: 2,\r\n};\r\nUpdateType[UpdateType.Default] = 'Default';\r\nUpdateType[UpdateType.Update] = 'Update';\r\nUpdateType[UpdateType.Refresh] = 'Refresh';\r\nclass BaseChartDirective {\r\n    /**\r\n     * @param {?} element\r\n     * @param {?} themeService\r\n     */\r\n    constructor(element, themeService) {\r\n        this.element = element;\r\n        this.themeService = themeService;\r\n        this.options = {};\r\n        this.chartClick = new EventEmitter();\r\n        this.chartHover = new EventEmitter();\r\n        this.old = {\r\n            dataExists: false,\r\n            dataLength: 0,\r\n            datasetsExists: false,\r\n            datasetsLength: 0,\r\n            datasetsDataObjects: [],\r\n            datasetsDataLengths: [],\r\n            colorsExists: false,\r\n            colors: [],\r\n            labelsExist: false,\r\n            labels: [],\r\n            legendExists: false,\r\n            legend: {},\r\n        };\r\n        this.subs = [];\r\n    }\r\n    /**\r\n     * Register a plugin.\r\n     * @param {?} plugin\r\n     * @return {?}\r\n     */\r\n    static registerPlugin(plugin) {\r\n        Chart$1.plugins.register(plugin);\r\n    }\r\n    /**\r\n     * @param {?} plugin\r\n     * @return {?}\r\n     */\r\n    static unregisterPlugin(plugin) {\r\n        Chart$1.plugins.unregister(plugin);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnInit() {\r\n        this.ctx = this.element.nativeElement.getContext('2d');\r\n        this.refresh();\r\n        this.subs.push(this.themeService.colorschemesOptions.subscribe((/**\r\n         * @param {?} r\r\n         * @return {?}\r\n         */\r\n        r => this.themeChanged(r))));\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} options\r\n     * @return {?}\r\n     */\r\n    themeChanged(options) {\r\n        this.refresh();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngDoCheck() {\r\n        if (!this.chart) {\r\n            return;\r\n        }\r\n        /** @type {?} */\r\n        let updateRequired = UpdateType.Default;\r\n        /** @type {?} */\r\n        const wantUpdate = (/**\r\n         * @param {?} x\r\n         * @return {?}\r\n         */\r\n        (x) => {\r\n            updateRequired = x > updateRequired ? x : updateRequired;\r\n        });\r\n        if (!!this.data !== this.old.dataExists) {\r\n            this.propagateDataToDatasets(this.data);\r\n            this.old.dataExists = !!this.data;\r\n            wantUpdate(UpdateType.Update);\r\n        }\r\n        if (this.data && this.data.length !== this.old.dataLength) {\r\n            this.old.dataLength = this.data && this.data.length || 0;\r\n            wantUpdate(UpdateType.Update);\r\n        }\r\n        if (!!this.datasets !== this.old.datasetsExists) {\r\n            this.old.datasetsExists = !!this.datasets;\r\n            wantUpdate(UpdateType.Update);\r\n        }\r\n        if (this.datasets && this.datasets.length !== this.old.datasetsLength) {\r\n            this.old.datasetsLength = this.datasets && this.datasets.length || 0;\r\n            wantUpdate(UpdateType.Update);\r\n        }\r\n        if (this.datasets && this.datasets.filter((/**\r\n         * @param {?} x\r\n         * @param {?} i\r\n         * @return {?}\r\n         */\r\n        (x, i) => x.data !== this.old.datasetsDataObjects[i])).length) {\r\n            this.old.datasetsDataObjects = this.datasets.map((/**\r\n             * @param {?} x\r\n             * @return {?}\r\n             */\r\n            x => x.data));\r\n            wantUpdate(UpdateType.Update);\r\n        }\r\n        if (this.datasets && this.datasets.filter((/**\r\n         * @param {?} x\r\n         * @param {?} i\r\n         * @return {?}\r\n         */\r\n        (x, i) => x.data.length !== this.old.datasetsDataLengths[i])).length) {\r\n            this.old.datasetsDataLengths = this.datasets.map((/**\r\n             * @param {?} x\r\n             * @return {?}\r\n             */\r\n            x => x.data.length));\r\n            wantUpdate(UpdateType.Update);\r\n        }\r\n        if (!!this.colors !== this.old.colorsExists) {\r\n            this.old.colorsExists = !!this.colors;\r\n            this.updateColors();\r\n            wantUpdate(UpdateType.Update);\r\n        }\r\n        // This smells of inefficiency, might need to revisit this\r\n        if (this.colors && this.colors.filter((/**\r\n         * @param {?} x\r\n         * @param {?} i\r\n         * @return {?}\r\n         */\r\n        (x, i) => !this.colorsEqual(x, this.old.colors[i]))).length) {\r\n            this.old.colors = this.colors.map((/**\r\n             * @param {?} x\r\n             * @return {?}\r\n             */\r\n            x => this.copyColor(x)));\r\n            this.updateColors();\r\n            wantUpdate(UpdateType.Update);\r\n        }\r\n        if (!!this.labels !== this.old.labelsExist) {\r\n            this.old.labelsExist = !!this.labels;\r\n            wantUpdate(UpdateType.Update);\r\n        }\r\n        if (this.labels && this.labels.filter((/**\r\n         * @param {?} x\r\n         * @param {?} i\r\n         * @return {?}\r\n         */\r\n        (x, i) => !this.labelsEqual(x, this.old.labels[i]))).length) {\r\n            this.old.labels = this.labels.map((/**\r\n             * @param {?} x\r\n             * @return {?}\r\n             */\r\n            x => this.copyLabel(x)));\r\n            wantUpdate(UpdateType.Update);\r\n        }\r\n        if (!!this.options.legend !== this.old.legendExists) {\r\n            this.old.legendExists = !!this.options.legend;\r\n            wantUpdate(UpdateType.Refresh);\r\n        }\r\n        if (this.options.legend && this.options.legend.position !== this.old.legend.position) {\r\n            this.old.legend.position = this.options.legend.position;\r\n            wantUpdate(UpdateType.Refresh);\r\n        }\r\n        switch ((/** @type {?} */ (updateRequired))) {\r\n            case UpdateType.Default:\r\n                break;\r\n            case UpdateType.Update:\r\n                this.update();\r\n                break;\r\n            case UpdateType.Refresh:\r\n                this.refresh();\r\n                break;\r\n        }\r\n    }\r\n    /**\r\n     * @param {?} a\r\n     * @return {?}\r\n     */\r\n    copyLabel(a) {\r\n        if (Array.isArray(a)) {\r\n            return [...a];\r\n        }\r\n        return a;\r\n    }\r\n    /**\r\n     * @param {?} a\r\n     * @param {?} b\r\n     * @return {?}\r\n     */\r\n    labelsEqual(a, b) {\r\n        return Array.isArray(a) === Array.isArray(b)\r\n            && (Array.isArray(a) || a === b)\r\n            && (!Array.isArray(a) || a.length === b.length)\r\n            && (!Array.isArray(a) || a.filter((/**\r\n             * @param {?} x\r\n             * @param {?} i\r\n             * @return {?}\r\n             */\r\n            (x, i) => x !== b[i])).length === 0);\r\n    }\r\n    /**\r\n     * @param {?} a\r\n     * @return {?}\r\n     */\r\n    copyColor(a) {\r\n        /** @type {?} */\r\n        const rc = {\r\n            backgroundColor: a.backgroundColor,\r\n            borderWidth: a.borderWidth,\r\n            borderColor: a.borderColor,\r\n            borderCapStyle: a.borderCapStyle,\r\n            borderDash: a.borderDash,\r\n            borderDashOffset: a.borderDashOffset,\r\n            borderJoinStyle: a.borderJoinStyle,\r\n            pointBorderColor: a.pointBorderColor,\r\n            pointBackgroundColor: a.pointBackgroundColor,\r\n            pointBorderWidth: a.pointBorderWidth,\r\n            pointRadius: a.pointRadius,\r\n            pointHoverRadius: a.pointHoverRadius,\r\n            pointHitRadius: a.pointHitRadius,\r\n            pointHoverBackgroundColor: a.pointHoverBackgroundColor,\r\n            pointHoverBorderColor: a.pointHoverBorderColor,\r\n            pointHoverBorderWidth: a.pointHoverBorderWidth,\r\n            pointStyle: a.pointStyle,\r\n            hoverBackgroundColor: a.hoverBackgroundColor,\r\n            hoverBorderColor: a.hoverBorderColor,\r\n            hoverBorderWidth: a.hoverBorderWidth,\r\n        };\r\n        return rc;\r\n    }\r\n    /**\r\n     * @param {?} a\r\n     * @param {?} b\r\n     * @return {?}\r\n     */\r\n    colorsEqual(a, b) {\r\n        if (!a !== !b) {\r\n            return false;\r\n        }\r\n        return !a || a.backgroundColor === b.backgroundColor\r\n            && (a.borderWidth === b.borderWidth)\r\n            && (a.borderColor === b.borderColor)\r\n            && (a.borderCapStyle === b.borderCapStyle)\r\n            && (a.borderDash === b.borderDash)\r\n            && (a.borderDashOffset === b.borderDashOffset)\r\n            && (a.borderJoinStyle === b.borderJoinStyle)\r\n            && (a.pointBorderColor === b.pointBorderColor)\r\n            && (a.pointBackgroundColor === b.pointBackgroundColor)\r\n            && (a.pointBorderWidth === b.pointBorderWidth)\r\n            && (a.pointRadius === b.pointRadius)\r\n            && (a.pointHoverRadius === b.pointHoverRadius)\r\n            && (a.pointHitRadius === b.pointHitRadius)\r\n            && (a.pointHoverBackgroundColor === b.pointHoverBackgroundColor)\r\n            && (a.pointHoverBorderColor === b.pointHoverBorderColor)\r\n            && (a.pointHoverBorderWidth === b.pointHoverBorderWidth)\r\n            && (a.pointStyle === b.pointStyle)\r\n            && (a.hoverBackgroundColor === b.hoverBackgroundColor)\r\n            && (a.hoverBorderColor === b.hoverBorderColor)\r\n            && (a.hoverBorderWidth === b.hoverBorderWidth);\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    updateColors() {\r\n        this.datasets.forEach((/**\r\n         * @param {?} elm\r\n         * @param {?} index\r\n         * @return {?}\r\n         */\r\n        (elm, index) => {\r\n            if (this.colors && this.colors[index]) {\r\n                Object.assign(elm, this.colors[index]);\r\n            }\r\n            else {\r\n                Object.assign(elm, getColors(this.chartType, index, elm.data.length), Object.assign({}, elm));\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\r\n    ngOnChanges(changes) {\r\n        /** @type {?} */\r\n        let updateRequired = UpdateType.Default;\r\n        /** @type {?} */\r\n        const wantUpdate = (/**\r\n         * @param {?} x\r\n         * @return {?}\r\n         */\r\n        (x) => {\r\n            updateRequired = x > updateRequired ? x : updateRequired;\r\n        });\r\n        // Check if the changes are in the data or datasets or labels or legend\r\n        if (changes.hasOwnProperty('data') && changes.data.currentValue) {\r\n            this.propagateDataToDatasets(changes.data.currentValue);\r\n            wantUpdate(UpdateType.Update);\r\n        }\r\n        if (changes.hasOwnProperty('datasets') && changes.datasets.currentValue) {\r\n            this.propagateDatasetsToData(changes.datasets.currentValue);\r\n            wantUpdate(UpdateType.Update);\r\n        }\r\n        if (changes.hasOwnProperty('labels')) {\r\n            if (this.chart) {\r\n                this.chart.data.labels = changes.labels.currentValue;\r\n            }\r\n            wantUpdate(UpdateType.Update);\r\n        }\r\n        if (changes.hasOwnProperty('legend')) {\r\n            if (this.chart) {\r\n                this.chart.config.options.legend.display = changes.legend.currentValue;\r\n                this.chart.generateLegend();\r\n            }\r\n            wantUpdate(UpdateType.Update);\r\n        }\r\n        if (changes.hasOwnProperty('options')) {\r\n            wantUpdate(UpdateType.Refresh);\r\n        }\r\n        switch ((/** @type {?} */ (updateRequired))) {\r\n            case UpdateType.Update:\r\n                this.update();\r\n                break;\r\n            case UpdateType.Refresh:\r\n            case UpdateType.Default:\r\n                this.refresh();\r\n                break;\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        if (this.chart) {\r\n            this.chart.destroy();\r\n            this.chart = void 0;\r\n        }\r\n        this.subs.forEach((/**\r\n         * @param {?} x\r\n         * @return {?}\r\n         */\r\n        x => x.unsubscribe()));\r\n    }\r\n    /**\r\n     * @param {?=} duration\r\n     * @param {?=} lazy\r\n     * @return {?}\r\n     */\r\n    update(duration, lazy) {\r\n        if (this.chart) {\r\n            return this.chart.update(duration, lazy);\r\n        }\r\n    }\r\n    /**\r\n     * @param {?} index\r\n     * @param {?} hidden\r\n     * @return {?}\r\n     */\r\n    hideDataset(index, hidden) {\r\n        this.chart.getDatasetMeta(index).hidden = hidden;\r\n        this.chart.update();\r\n    }\r\n    /**\r\n     * @param {?} index\r\n     * @return {?}\r\n     */\r\n    isDatasetHidden(index) {\r\n        return this.chart.getDatasetMeta(index).hidden;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    toBase64Image() {\r\n        return this.chart.toBase64Image();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    getChartConfiguration() {\r\n        /** @type {?} */\r\n        const datasets = this.getDatasets();\r\n        /** @type {?} */\r\n        const options = Object.assign({}, this.options);\r\n        if (this.legend === false) {\r\n            options.legend = { display: false };\r\n        }\r\n        // hook for onHover and onClick events\r\n        options.hover = options.hover || {};\r\n        if (!options.hover.onHover) {\r\n            options.hover.onHover = (/**\r\n             * @param {?} event\r\n             * @param {?} active\r\n             * @return {?}\r\n             */\r\n            (event, active) => {\r\n                if (active && !active.length) {\r\n                    return;\r\n                }\r\n                this.chartHover.emit({ event, active });\r\n            });\r\n        }\r\n        if (!options.onClick) {\r\n            options.onClick = (/**\r\n             * @param {?=} event\r\n             * @param {?=} active\r\n             * @return {?}\r\n             */\r\n            (event, active) => {\r\n                this.chartClick.emit({ event, active });\r\n            });\r\n        }\r\n        /** @type {?} */\r\n        const mergedOptions = this.smartMerge(options, this.themeService.getColorschemesOptions());\r\n        /** @type {?} */\r\n        const chartConfig = {\r\n            type: this.chartType,\r\n            data: {\r\n                labels: this.labels || [],\r\n                datasets\r\n            },\r\n            plugins: this.plugins,\r\n            options: mergedOptions,\r\n        };\r\n        return chartConfig;\r\n    }\r\n    /**\r\n     * @param {?} ctx\r\n     * @return {?}\r\n     */\r\n    getChartBuilder(ctx /*, data:any[], options:any*/) {\r\n        /** @type {?} */\r\n        const chartConfig = this.getChartConfiguration();\r\n        return new Chart$1(ctx, chartConfig);\r\n    }\r\n    /**\r\n     * @param {?} options\r\n     * @param {?} overrides\r\n     * @param {?=} level\r\n     * @return {?}\r\n     */\r\n    smartMerge(options, overrides, level = 0) {\r\n        if (level === 0) {\r\n            options = cloneDeep(options);\r\n        }\r\n        /** @type {?} */\r\n        const keysToUpdate = Object.keys(overrides);\r\n        keysToUpdate.forEach((/**\r\n         * @param {?} key\r\n         * @return {?}\r\n         */\r\n        key => {\r\n            if (Array.isArray(overrides[key])) {\r\n                /** @type {?} */\r\n                const arrayElements = options[key];\r\n                if (arrayElements) {\r\n                    arrayElements.forEach((/**\r\n                     * @param {?} r\r\n                     * @return {?}\r\n                     */\r\n                    r => {\r\n                        this.smartMerge(r, overrides[key][0], level + 1);\r\n                    }));\r\n                }\r\n            }\r\n            else if (typeof (overrides[key]) === 'object') {\r\n                if (!(key in options)) {\r\n                    options[key] = {};\r\n                }\r\n                this.smartMerge(options[key], overrides[key], level + 1);\r\n            }\r\n            else {\r\n                options[key] = overrides[key];\r\n            }\r\n        }));\r\n        if (level === 0) {\r\n            return options;\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} label\r\n     * @return {?}\r\n     */\r\n    isMultiLineLabel(label) {\r\n        return Array.isArray(label);\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} label\r\n     * @return {?}\r\n     */\r\n    joinLabel(label) {\r\n        if (!label) {\r\n            return null;\r\n        }\r\n        if (this.isMultiLineLabel(label)) {\r\n            return label.join(' ');\r\n        }\r\n        else {\r\n            return label;\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} datasets\r\n     * @return {?}\r\n     */\r\n    propagateDatasetsToData(datasets) {\r\n        this.data = this.datasets.map((/**\r\n         * @param {?} r\r\n         * @return {?}\r\n         */\r\n        r => r.data));\r\n        if (this.chart) {\r\n            this.chart.data.datasets = datasets;\r\n        }\r\n        this.updateColors();\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} newDataValues\r\n     * @return {?}\r\n     */\r\n    propagateDataToDatasets(newDataValues) {\r\n        if (this.isMultiDataSet(newDataValues)) {\r\n            if (this.datasets && newDataValues.length === this.datasets.length) {\r\n                this.datasets.forEach((/**\r\n                 * @param {?} dataset\r\n                 * @param {?} i\r\n                 * @return {?}\r\n                 */\r\n                (dataset, i) => {\r\n                    dataset.data = newDataValues[i];\r\n                }));\r\n            }\r\n            else {\r\n                this.datasets = newDataValues.map((/**\r\n                 * @param {?} data\r\n                 * @param {?} index\r\n                 * @return {?}\r\n                 */\r\n                (data, index) => {\r\n                    return { data, label: this.joinLabel(this.labels[index]) || `Label ${index}` };\r\n                }));\r\n                if (this.chart) {\r\n                    this.chart.data.datasets = this.datasets;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (!this.datasets) {\r\n                this.datasets = [{ data: newDataValues }];\r\n                if (this.chart) {\r\n                    this.chart.data.datasets = this.datasets;\r\n                }\r\n            }\r\n            else {\r\n                this.datasets[0].data = newDataValues;\r\n                this.datasets.splice(1); // Remove all elements but the first\r\n            }\r\n        }\r\n        this.updateColors();\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {?} data\r\n     * @return {?}\r\n     */\r\n    isMultiDataSet(data) {\r\n        return Array.isArray(data[0]);\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    getDatasets() {\r\n        if (!this.datasets && !this.data) {\r\n            throw new Error(`ng-charts configuration error, data or datasets field are required to render chart ${this.chartType}`);\r\n        }\r\n        // If `datasets` is defined, use it over the `data` property.\r\n        if (this.datasets) {\r\n            this.propagateDatasetsToData(this.datasets);\r\n            return this.datasets;\r\n        }\r\n        if (this.data) {\r\n            this.propagateDataToDatasets(this.data);\r\n            return this.datasets;\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    refresh() {\r\n        // if (this.options && this.options.responsive) {\r\n        //   setTimeout(() => this.refresh(), 50);\r\n        // }\r\n        // todo: remove this line, it is producing flickering\r\n        if (this.chart) {\r\n            this.chart.destroy();\r\n            this.chart = void 0;\r\n        }\r\n        if (this.ctx) {\r\n            this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);\r\n        }\r\n    }\r\n}\r\nBaseChartDirective.decorators = [\r\n    { type: Directive, args: [{\r\n                // tslint:disable-next-line:directive-selector\r\n                selector: 'canvas[baseChart]',\r\n                exportAs: 'base-chart'\r\n            },] }\r\n];\r\n/** @nocollapse */\r\nBaseChartDirective.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: ThemeService }\r\n];\r\nBaseChartDirective.propDecorators = {\r\n    data: [{ type: Input }],\r\n    datasets: [{ type: Input }],\r\n    labels: [{ type: Input }],\r\n    options: [{ type: Input }],\r\n    chartType: [{ type: Input }],\r\n    colors: [{ type: Input }],\r\n    legend: [{ type: Input }],\r\n    plugins: [{ type: Input }],\r\n    chartClick: [{ type: Output }],\r\n    chartHover: [{ type: Output }]\r\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass ChartsModule {\r\n}\r\nChartsModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                declarations: [\r\n                    BaseChartDirective\r\n                ],\r\n                imports: [],\r\n                exports: [\r\n                    BaseChartDirective\r\n                ]\r\n            },] }\r\n];\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n// tslint:disable:variable-name\r\n// tslint:disable:no-var-keyword\r\n// tslint:disable:prefer-const\r\n// tslint:disable:only-arrow-functions\r\n// tslint:disable:one-variable-per-declaration\r\n// tslint:disable:object-literal-shorthand\r\n// tslint:disable:space-before-function-paren\r\n/**\r\n * @return {?}\r\n */\r\nfunction monkeyPatchChartJsLegend() {\r\n    if (typeof Chart === 'undefined') {\r\n        console.log('Chart not defined (guessing this is a universal build, and I don\\'t know why this happens -- Aviad)');\r\n        return;\r\n    }\r\n    /** @type {?} */\r\n    const plugins = Chart.plugins.getAll();\r\n    /** @type {?} */\r\n    const legend = plugins.filter((/**\r\n     * @param {?} p\r\n     * @return {?}\r\n     */\r\n    p => p.id === 'legend'))[0];\r\n    legend._element.prototype.fit = fit;\r\n    legend._element.prototype.draw = draw;\r\n    /** @type {?} */\r\n    const helpers = Chart.helpers;\r\n    /** @type {?} */\r\n    const defaults = Chart.defaults;\r\n    /** @type {?} */\r\n    const valueOrDefault = helpers.valueOrDefault;\r\n    /**\r\n     * @param {?} labelOpts\r\n     * @param {?} fontSize\r\n     * @return {?}\r\n     */\r\n    function getBoxWidth(labelOpts, fontSize) {\r\n        return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ?\r\n            fontSize :\r\n            labelOpts.boxWidth;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    function fit() {\r\n        /** @type {?} */\r\n        var me = this;\r\n        /** @type {?} */\r\n        var opts = me.options;\r\n        /** @type {?} */\r\n        var labelOpts = opts.labels;\r\n        /** @type {?} */\r\n        var display = opts.display;\r\n        /** @type {?} */\r\n        var ctx = me.ctx;\r\n        /** @type {?} */\r\n        var labelFont = helpers.options._parseFont(labelOpts);\r\n        /** @type {?} */\r\n        var fontSize = labelFont.size;\r\n        // Reset hit boxes\r\n        /** @type {?} */\r\n        var hitboxes = me.legendHitBoxes = [];\r\n        /** @type {?} */\r\n        var minSize = me.minSize;\r\n        /** @type {?} */\r\n        var isHorizontal = me.isHorizontal();\r\n        if (isHorizontal) {\r\n            minSize.width = me.maxWidth; // fill all the width\r\n            minSize.height = display ? 10 : 0;\r\n        }\r\n        else {\r\n            minSize.width = display ? 10 : 0;\r\n            minSize.height = me.maxHeight; // fill all the height\r\n        }\r\n        /** @type {?} */\r\n        var getMaxLineWidth = (/**\r\n         * @param {?} textLines\r\n         * @return {?}\r\n         */\r\n        function (textLines) {\r\n            return textLines.map((/**\r\n             * @param {?} textLine\r\n             * @return {?}\r\n             */\r\n            function (textLine) {\r\n                return ctx.measureText(textLine).width;\r\n            })).reduce((/**\r\n             * @param {?} acc\r\n             * @param {?} v\r\n             * @return {?}\r\n             */\r\n            function (acc, v) {\r\n                return v > acc ? v : acc;\r\n            }), 0);\r\n        });\r\n        // Increase sizes here\r\n        if (display) {\r\n            ctx.font = labelFont.string;\r\n            if (isHorizontal) {\r\n                // Labels\r\n                // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\r\n                /** @type {?} */\r\n                var lineWidths = me.lineWidths = [0];\r\n                /** @type {?} */\r\n                var lineHeights = me.lineHeights = [];\r\n                /** @type {?} */\r\n                var currentLineHeight = 0;\r\n                /** @type {?} */\r\n                var lineIndex = 0;\r\n                ctx.textAlign = 'left';\r\n                ctx.textBaseline = 'top';\r\n                helpers.each(me.legendItems, (/**\r\n                 * @param {?} legendItem\r\n                 * @param {?} i\r\n                 * @return {?}\r\n                 */\r\n                function (legendItem, i) {\r\n                    /** @type {?} */\r\n                    var width;\r\n                    /** @type {?} */\r\n                    var height;\r\n                    if (helpers.isArray(legendItem.text)) {\r\n                        width = getMaxLineWidth(legendItem.text);\r\n                        height = fontSize * legendItem.text.length + labelOpts.padding;\r\n                    }\r\n                    else {\r\n                        width = ctx.measureText(legendItem.text).width;\r\n                        height = fontSize + labelOpts.padding;\r\n                    }\r\n                    width += getBoxWidth(labelOpts, fontSize) + (fontSize / 2);\r\n                    if (lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {\r\n                        lineHeights.push(currentLineHeight);\r\n                        currentLineHeight = 0;\r\n                        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\r\n                        lineIndex++;\r\n                    }\r\n                    legendItem.lineOrColumnIndex = lineIndex;\r\n                    if (height > currentLineHeight) {\r\n                        currentLineHeight = height;\r\n                    }\r\n                    // Store the hitbox width and height here. Final position will be updated in `draw`\r\n                    hitboxes[i] = {\r\n                        left: 0,\r\n                        top: 0,\r\n                        width: width,\r\n                        height: height,\r\n                    };\r\n                    lineWidths[lineWidths.length - 1] += width + labelOpts.padding;\r\n                }));\r\n                lineHeights.push(currentLineHeight);\r\n                minSize.height += lineHeights.reduce((/**\r\n                 * @param {?} acc\r\n                 * @param {?} v\r\n                 * @return {?}\r\n                 */\r\n                function (acc, v) {\r\n                    return acc + v;\r\n                }), 0);\r\n            }\r\n            else {\r\n                /** @type {?} */\r\n                var vPadding = labelOpts.padding;\r\n                /** @type {?} */\r\n                var columnWidths = me.columnWidths = [];\r\n                /** @type {?} */\r\n                var columnHeights = me.columnHeights = [];\r\n                /** @type {?} */\r\n                var totalWidth = labelOpts.padding;\r\n                /** @type {?} */\r\n                var currentColWidth = 0;\r\n                /** @type {?} */\r\n                var currentColHeight = 0;\r\n                /** @type {?} */\r\n                var columnIndex = 0;\r\n                helpers.each(me.legendItems, (/**\r\n                 * @param {?} legendItem\r\n                 * @param {?} i\r\n                 * @return {?}\r\n                 */\r\n                function (legendItem, i) {\r\n                    /** @type {?} */\r\n                    var itemWidth;\r\n                    /** @type {?} */\r\n                    var height;\r\n                    if (helpers.isArray(legendItem.text)) {\r\n                        itemWidth = getMaxLineWidth(legendItem.text);\r\n                        height = fontSize * legendItem.text.length;\r\n                    }\r\n                    else {\r\n                        itemWidth = ctx.measureText(legendItem.text).width;\r\n                        height = fontSize;\r\n                    }\r\n                    itemWidth += getBoxWidth(labelOpts, fontSize) + (fontSize / 2);\r\n                    // If too tall, go to new column\r\n                    if (currentColHeight + fontSize + 2 * vPadding > minSize.height) {\r\n                        totalWidth += currentColWidth + labelOpts.padding;\r\n                        columnWidths.push(currentColWidth); // previous column width\r\n                        columnHeights.push(currentColHeight);\r\n                        currentColWidth = 0;\r\n                        currentColHeight = 0;\r\n                        columnIndex++;\r\n                    }\r\n                    legendItem.lineOrColumnIndex = columnIndex;\r\n                    // Get max width\r\n                    currentColWidth = Math.max(currentColWidth, itemWidth);\r\n                    currentColHeight += height + vPadding;\r\n                    // Store the hitbox width and height here. Final position will be updated in `draw`\r\n                    hitboxes[i] = {\r\n                        left: 0,\r\n                        top: 0,\r\n                        width: itemWidth,\r\n                        height: height\r\n                    };\r\n                }));\r\n                totalWidth += currentColWidth;\r\n                columnWidths.push(currentColWidth);\r\n                columnHeights.push(currentColHeight);\r\n                minSize.width += totalWidth;\r\n            }\r\n        }\r\n        me.width = minSize.width;\r\n        me.height = minSize.height;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    function draw() {\r\n        /** @type {?} */\r\n        var me = this;\r\n        /** @type {?} */\r\n        var opts = me.options;\r\n        /** @type {?} */\r\n        var labelOpts = opts.labels;\r\n        /** @type {?} */\r\n        var globalDefaults = defaults.global;\r\n        /** @type {?} */\r\n        var defaultColor = globalDefaults.defaultColor;\r\n        /** @type {?} */\r\n        var lineDefault = globalDefaults.elements.line;\r\n        /** @type {?} */\r\n        var legendHeight = me.height;\r\n        /** @type {?} */\r\n        var columnHeights = me.columnHeights;\r\n        /** @type {?} */\r\n        var columnWidths = me.columnWidths;\r\n        /** @type {?} */\r\n        var legendWidth = me.width;\r\n        /** @type {?} */\r\n        var lineWidths = me.lineWidths;\r\n        /** @type {?} */\r\n        var lineHeights = me.lineHeights;\r\n        if (opts.display) {\r\n            /** @type {?} */\r\n            var ctx = me.ctx;\r\n            /** @type {?} */\r\n            var fontColor = valueOrDefault(labelOpts.fontColor, globalDefaults.defaultFontColor);\r\n            /** @type {?} */\r\n            var labelFont = helpers.options._parseFont(labelOpts);\r\n            /** @type {?} */\r\n            var fontSize = labelFont.size;\r\n            /** @type {?} */\r\n            var cursor;\r\n            // Canvas setup\r\n            ctx.textAlign = 'left';\r\n            ctx.textBaseline = 'middle';\r\n            ctx.lineWidth = 0.5;\r\n            ctx.strokeStyle = fontColor; // for strikethrough effect\r\n            ctx.fillStyle = fontColor; // render in correct colour\r\n            ctx.font = labelFont.string;\r\n            /** @type {?} */\r\n            var boxWidth = getBoxWidth(labelOpts, fontSize);\r\n            /** @type {?} */\r\n            var hitboxes = me.legendHitBoxes;\r\n            // current position\r\n            /** @type {?} */\r\n            var drawLegendBox = (/**\r\n             * @param {?} x\r\n             * @param {?} y\r\n             * @param {?} legendItem\r\n             * @return {?}\r\n             */\r\n            function (x, y, legendItem) {\r\n                if (isNaN(boxWidth) || boxWidth <= 0) {\r\n                    return;\r\n                }\r\n                // Set the ctx for the box\r\n                ctx.save();\r\n                /** @type {?} */\r\n                var lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\r\n                ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\r\n                ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\r\n                ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\r\n                ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\r\n                ctx.lineWidth = lineWidth;\r\n                ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\r\n                if (ctx.setLineDash) {\r\n                    // IE 9 and 10 do not support line dash\r\n                    ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));\r\n                }\r\n                if (opts.labels && opts.labels.usePointStyle) {\r\n                    // Recalculate x and y for drawPoint() because its expecting\r\n                    // x and y to be center of figure (instead of top left)\r\n                    /** @type {?} */\r\n                    var radius = boxWidth * Math.SQRT2 / 2;\r\n                    /** @type {?} */\r\n                    var centerX = x + boxWidth / 2;\r\n                    /** @type {?} */\r\n                    var centerY = y + fontSize / 2;\r\n                    // Draw pointStyle as legend symbol\r\n                    helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\r\n                }\r\n                else {\r\n                    // Draw box as legend symbol\r\n                    if (lineWidth !== 0) {\r\n                        ctx.strokeRect(x, y, boxWidth, fontSize);\r\n                    }\r\n                    ctx.fillRect(x, y, boxWidth, fontSize);\r\n                }\r\n                ctx.restore();\r\n            });\r\n            /** @type {?} */\r\n            var drawStrikeThrough = (/**\r\n             * @param {?} x\r\n             * @param {?} y\r\n             * @param {?} w\r\n             * @return {?}\r\n             */\r\n            function (x, y, w) {\r\n                ctx.beginPath();\r\n                ctx.lineWidth = 2;\r\n                ctx.moveTo(x, y);\r\n                ctx.lineTo(x + w, y);\r\n                ctx.stroke();\r\n            });\r\n            /** @type {?} */\r\n            var drawCrossOver = (/**\r\n             * @param {?} x\r\n             * @param {?} y\r\n             * @param {?} w\r\n             * @param {?} h\r\n             * @return {?}\r\n             */\r\n            function (x, y, w, h) {\r\n                ctx.beginPath();\r\n                ctx.lineWidth = 2;\r\n                ctx.moveTo(x, y);\r\n                ctx.lineTo(x + w, y + h);\r\n                ctx.moveTo(x, y + h);\r\n                ctx.lineTo(x + w, y);\r\n                ctx.stroke();\r\n            });\r\n            /** @type {?} */\r\n            var fillText = (/**\r\n             * @param {?} x\r\n             * @param {?} y\r\n             * @param {?} legendItem\r\n             * @param {?} textWidth\r\n             * @return {?}\r\n             */\r\n            function (x, y, legendItem, textWidth) {\r\n                /** @type {?} */\r\n                var halfFontSize = fontSize / 2;\r\n                /** @type {?} */\r\n                var xLeft = boxWidth + halfFontSize + x;\r\n                /** @type {?} */\r\n                var yMiddle = y + halfFontSize;\r\n                if (helpers.isArray(legendItem.text)) {\r\n                    helpers.each(legendItem.text, (/**\r\n                     * @param {?} textLine\r\n                     * @param {?} index\r\n                     * @return {?}\r\n                     */\r\n                    function (textLine, index) {\r\n                        /** @type {?} */\r\n                        var lineOffset = index * fontSize;\r\n                        ctx.fillText(textLine, xLeft, yMiddle + lineOffset);\r\n                    }));\r\n                }\r\n                else {\r\n                    ctx.fillText(legendItem.text, xLeft, yMiddle);\r\n                }\r\n                if (legendItem.hidden) {\r\n                    if (helpers.isArray(legendItem.text)) {\r\n                        drawCrossOver(xLeft, yMiddle, textWidth, (legendItem.text.length - 1) * (fontSize - 1));\r\n                    }\r\n                    else {\r\n                        drawStrikeThrough(xLeft, yMiddle, textWidth);\r\n                    }\r\n                }\r\n            });\r\n            /** @type {?} */\r\n            var alignmentOffset = (/**\r\n             * @param {?} dimension\r\n             * @param {?} blockSize\r\n             * @return {?}\r\n             */\r\n            function (dimension, blockSize) {\r\n                switch (opts.align) {\r\n                    case 'start':\r\n                        return labelOpts.padding;\r\n                    case 'end':\r\n                        return dimension - blockSize;\r\n                    default: // center\r\n                        return (dimension - blockSize + labelOpts.padding) / 2;\r\n                }\r\n            });\r\n            // Horizontal\r\n            /** @type {?} */\r\n            var isHorizontal = me.isHorizontal();\r\n            if (isHorizontal) {\r\n                cursor = {\r\n                    x: me.left + alignmentOffset(legendWidth, lineWidths[0]),\r\n                    y: me.top + labelOpts.padding,\r\n                    line: 0\r\n                };\r\n            }\r\n            else {\r\n                cursor = {\r\n                    x: me.left + labelOpts.padding,\r\n                    y: me.top + alignmentOffset(legendHeight, columnHeights[0]),\r\n                    line: 0\r\n                };\r\n            }\r\n            helpers.each(me.legendItems, (/**\r\n             * @param {?} legendItem\r\n             * @param {?} i\r\n             * @return {?}\r\n             */\r\n            function (legendItem, i) {\r\n                /** @type {?} */\r\n                var textWidth;\r\n                /** @type {?} */\r\n                var height;\r\n                /** @type {?} */\r\n                var boxTopOffset;\r\n                if (legendItem.lineOrColumnIndex > cursor.line) {\r\n                    if (isHorizontal) {\r\n                        cursor.y += lineHeights[cursor.line];\r\n                        cursor.line = legendItem.lineOrColumnIndex;\r\n                        cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);\r\n                    }\r\n                    else {\r\n                        cursor.x += columnWidths[cursor.line] + labelOpts.padding;\r\n                        cursor.line = legendItem.lineOrColumnIndex;\r\n                        cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);\r\n                    }\r\n                }\r\n                if (helpers.isArray(legendItem.text)) {\r\n                    textWidth = legendItem.text.map((/**\r\n                     * @param {?} textLine\r\n                     * @return {?}\r\n                     */\r\n                    function (textLine) {\r\n                        return ctx.measureText(textLine).width;\r\n                    })).reduce((/**\r\n                     * @param {?} acc\r\n                     * @param {?} v\r\n                     * @return {?}\r\n                     */\r\n                    function (acc, v) {\r\n                        return v > acc ? v : acc;\r\n                    }), 0);\r\n                    boxTopOffset = fontSize / 2 * (legendItem.text.length - 1);\r\n                    height = fontSize * legendItem.text.length;\r\n                }\r\n                else {\r\n                    textWidth = ctx.measureText(legendItem.text).width;\r\n                    boxTopOffset = 0;\r\n                    height = fontSize;\r\n                }\r\n                /** @type {?} */\r\n                var width = boxWidth + (fontSize / 2) + textWidth;\r\n                /** @type {?} */\r\n                var x = cursor.x;\r\n                /** @type {?} */\r\n                var y = cursor.y;\r\n                /** @type {?} */\r\n                var topOffset = isHorizontal ? Math.trunc((lineHeights[cursor.line] - hitboxes[i].height) / 2) : 0;\r\n                drawLegendBox(x, y + boxTopOffset + topOffset, legendItem);\r\n                hitboxes[i].left = x;\r\n                hitboxes[i].top = y;\r\n                // Fill the actual label\r\n                fillText(x, y + topOffset, legendItem, textWidth);\r\n                if (isHorizontal) {\r\n                    cursor.x += width + labelOpts.padding;\r\n                }\r\n                else {\r\n                    cursor.y += height + labelOpts.padding;\r\n                }\r\n            }));\r\n        }\r\n    }\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n// tslint:disable:variable-name\r\n// tslint:disable:no-var-keyword\r\n// tslint:disable:prefer-const\r\n// tslint:disable:only-arrow-functions\r\n// tslint:disable:one-variable-per-declaration\r\n// tslint:disable:object-literal-shorthand\r\n// tslint:disable:space-before-function-paren\r\n/**\r\n * @return {?}\r\n */\r\nfunction monkeyPatchChartJsTooltip() {\r\n    if (typeof Chart === 'undefined') {\r\n        console.log('Chart not defined (guessing this is a universal build, and I don\\'t know why this happens -- Aviad)');\r\n        return;\r\n    }\r\n    Chart.Tooltip.prototype.drawBody = drawBody;\r\n    /** @type {?} */\r\n    const helpers = Chart.helpers;\r\n    /**\r\n     * @param {?} vm\r\n     * @param {?} align\r\n     * @return {?}\r\n     */\r\n    function getAlignedX(vm, align) {\r\n        return align === 'center'\r\n            ? vm.x + vm.width / 2\r\n            : align === 'right'\r\n                ? vm.x + vm.width - vm.xPadding\r\n                : vm.x + vm.xPadding;\r\n    }\r\n    /**\r\n     * @param {?} pt\r\n     * @param {?} vm\r\n     * @param {?} ctx\r\n     * @return {?}\r\n     */\r\n    function drawBody(pt, vm, ctx) {\r\n        /** @type {?} */\r\n        var bodyFontSize = vm.bodyFontSize;\r\n        /** @type {?} */\r\n        var bodySpacing = vm.bodySpacing;\r\n        /** @type {?} */\r\n        var bodyAlign = vm._bodyAlign;\r\n        /** @type {?} */\r\n        var body = vm.body;\r\n        /** @type {?} */\r\n        var drawColorBoxes = vm.displayColors;\r\n        /** @type {?} */\r\n        var labelColors = vm.labelColors;\r\n        /** @type {?} */\r\n        var xLinePadding = 0;\r\n        /** @type {?} */\r\n        var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;\r\n        /** @type {?} */\r\n        var textColor;\r\n        ctx.textAlign = bodyAlign;\r\n        ctx.textBaseline = 'top';\r\n        ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\r\n        pt.x = getAlignedX(vm, bodyAlign);\r\n        // Before Body\r\n        /** @type {?} */\r\n        var fillLineOfText = (/**\r\n         * @param {?} line\r\n         * @return {?}\r\n         */\r\n        function (line) {\r\n            ctx.fillText(line, pt.x + xLinePadding, pt.y);\r\n            pt.y += bodyFontSize + bodySpacing;\r\n        });\r\n        // Before body lines\r\n        ctx.fillStyle = vm.bodyFontColor;\r\n        helpers.each(vm.beforeBody, fillLineOfText);\r\n        xLinePadding = drawColorBoxes && bodyAlign !== 'right'\r\n            ? bodyAlign === 'center' ? (bodyFontSize / 2 + 1) : (bodyFontSize + 2)\r\n            : 0;\r\n        // Draw body lines now\r\n        helpers.each(body, (/**\r\n         * @param {?} bodyItem\r\n         * @param {?} i\r\n         * @return {?}\r\n         */\r\n        function (bodyItem, i) {\r\n            textColor = vm.labelTextColors[i];\r\n            ctx.fillStyle = textColor;\r\n            helpers.each(bodyItem.before, fillLineOfText);\r\n            // Draw Legend-like boxes if needed\r\n            if (drawColorBoxes) {\r\n                // Fill a white rect so that colours merge nicely if the opacity is < 1\r\n                ctx.fillStyle = vm.legendColorBackground;\r\n                ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize);\r\n                // Border\r\n                ctx.lineWidth = 1;\r\n                ctx.strokeStyle = labelColors[i].borderColor;\r\n                ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize);\r\n                // Inner square\r\n                ctx.fillStyle = labelColors[i].backgroundColor;\r\n                ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\r\n                ctx.fillStyle = textColor;\r\n            }\r\n            helpers.each(bodyItem.lines, fillLineOfText);\r\n            helpers.each(bodyItem.after, fillLineOfText);\r\n        }));\r\n        // Reset back to 0 for after body\r\n        xLinePadding = 0;\r\n        // After body lines\r\n        helpers.each(vm.afterBody, fillLineOfText);\r\n        pt.y -= bodySpacing; // Remove last body spacing\r\n    }\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\nexport { ChartsModule, BaseChartDirective, defaultColors, ThemeService, monkeyPatchChartJsLegend, monkeyPatchChartJsTooltip };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}